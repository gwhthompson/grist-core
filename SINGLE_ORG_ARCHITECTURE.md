# GRIST_SINGLE_ORG Architecture and Design Intent

## Overview

This document explains the architectural design and implementation of `GRIST_SINGLE_ORG` mode in Grist, including the rationale behind key decisions and the behavior users should expect.

## Purpose of GRIST_SINGLE_ORG

The `GRIST_SINGLE_ORG` environment variable controls how Grist organizes users and their workspaces. It enables three distinct deployment modes:

### 1. Multi-Org Mode (GRIST_SINGLE_ORG not set)

**Use case:** Default behavior for self-hosted or cloud deployments where users collaborate across multiple organizations.

**Behavior:**
- Every user gets a personal org (domain: `docs-{userId}`)
- Users can create or join team orgs
- Users can switch between their personal org and team orgs
- Full multi-tenancy support

### 2. Personal-Only Mode (GRIST_SINGLE_ORG=docs)

**Use case:** Single-user or family deployments where collaboration is not needed.

**Behavior:**
- Every user gets a personal org (domain: `docs-{userId}`)
- No team orgs are expected
- All users' personal orgs are accessible
- Merged personal org view (`docs`) shows all users' content

**Special handling:** The value `docs` is treated as a "merged org" - a virtual organization that pools all personal orgs together. When document access is checked with `org=docs`, the system uses `WHERE orgs.owner_id IS NOT NULL` instead of filtering by domain, allowing all personal org documents to be accessible.

### 3. Single Team Mode (GRIST_SINGLE_ORG={team-domain})

**Use case:** Enterprise or team deployments where all users collaborate in one shared organization.

**Behavior:**
- Users do NOT get personal orgs
- All users are automatically added to the configured team org's MEMBERS group
- Users see only the configured team org
- Simplified UX with no org switching

**Architecture:** When set to a team domain, personal org creation is skipped during user signup. Instead, the system attempts to add the user to the MEMBERS group of the specified team org. This ensures architectural consistency: resources that exist are always accessible.

## Historical Context: The Inconsistency

Prior to this architectural clarification, Grist had a split-brain behavior:

**The Problem:**
```
GRIST_SINGLE_ORG=myteam

GET /api/orgs → Returns personal org {domain: "docs-5", ...} ✓
GET /api/orgs/2/workspaces → Returns workspaces ✓
POST /api/workspaces/2/docs → Creates doc successfully ✓
GET /api/docs/{docId} → 404 "document not found" ✗
```

**Root Cause:**
1. Personal orgs were ALWAYS created (no check for GRIST_SINGLE_ORG)
2. Personal org domain (`docs-*`) was generated POST-query, not stored in database
3. Document access used `WHERE orgs.domain = 'myteam'`, which didn't match personal orgs (domain = NULL in DB)
4. Result: Personal org docs existed in API listings but were inaccessible

This created "zombie resources" - they appeared to exist and could be manipulated, but couldn't actually be used.

## Architectural Solution

The fix implements **True Single Org** behavior:

### Code Changes

**File:** `app/gen-server/lib/homedb/UsersManager.ts` (lines 501-553)

```typescript
if (!user.personalOrg && !NON_LOGIN_EMAILS.includes(login.email)) {
  const singleOrg = process.env.GRIST_SINGLE_ORG;
  const shouldCreatePersonalOrg = !singleOrg || singleOrg === 'docs';

  if (shouldCreatePersonalOrg) {
    // Create personal org as before
  } else {
    // Skip personal org creation
    // Add user to team org's MEMBERS group
    await this._ensureUserInTeamOrg(user, singleOrg, manager);
  }
}
```

**Key decision:** Personal org creation is now conditional based on GRIST_SINGLE_ORG:
- `undefined` → Create personal org
- `"docs"` → Create personal org
- `"{team}"` → Skip personal org, add to team

### Helper Method: _ensureUserInTeamOrg

**File:** `app/gen-server/lib/homedb/UsersManager.ts` (lines 574-626)

```typescript
private async _ensureUserInTeamOrg(user: User, orgDomain: string, manager: EntityManager): Promise<void> {
  // 1. Find team org by domain
  // 2. Find MEMBERS group for that org
  // 3. Check if user already a member
  // 4. Add user to MEMBERS group
}
```

**Error handling philosophy:** User creation never fails due to team membership issues. If the team org doesn't exist or the MEMBERS group is missing, the system logs an error but completes user creation. This prevents lockout situations where misconfiguration would prevent all logins.

## Database Schema Notes

### Personal Org Domain Storage

Personal orgs have a unique characteristic: their domain is NOT stored in the database.

**Database:**
```sql
orgs table:
  id: 2
  domain: NULL
  owner_id: 5  -- Indicates personal org
```

**API Response:**
```json
{
  "id": 2,
  "domain": "docs-5",  // Generated by normalizeOrgDomain()
  "owner": {...}
}
```

**Why?** This design provides flexibility to change how personal orgs are presented without database migrations. The domain `docs-{userId}` is computed from the owner_id during query result normalization.

**Implication:** Document access queries must filter on `owner_id`, not `domain`, for personal orgs.

## Document Access Control Flow

```
GET /api/docs/{docId}
  │
  ├─ extractOrg middleware
  │  └─ If GRIST_SINGLE_ORG → req.org = process.env.GRIST_SINGLE_ORG
  │
  ├─ HomeDBManager.getDoc()
  │  └─ _doc() builds SQL query
  │     └─ _applyLimit(scope)
  │        └─ _whereOrg(scope.org)
  │           │
  │           ├─ If org === "docs" (or isMergedOrg returns true):
  │           │  └─ WHERE orgs.owner_id IS NOT NULL
  │           │     ✓ Matches all personal orgs
  │           │
  │           ├─ Else if org === "teamname":
  │           │  └─ WHERE orgs.domain = 'teamname'
  │           │     ✗ Doesn't match personal orgs (domain=NULL)
  │           │
  │           └─ Also applies user ACL filtering via _withAccess()
  │
  └─ Returns document or 404
```

## Configuration Best Practices

### Deployment Scenarios

#### Single-User Desktop/Docker
```bash
# Personal documents only
GRIST_SINGLE_ORG=docs
```

#### Small Team/Family
```bash
# Everyone collaborates, no personal docs
GRIST_SINGLE_ORG=family

# Ensure the "family" org exists:
# 1. Create first user (will fail to join org)
# 2. Log in as that user
# 3. Create team org with domain "family"
# 4. Manually add first user to MEMBERS
# 5. Future users auto-join
```

#### Enterprise
```bash
# All users in corporate org
GRIST_SINGLE_ORG=acmecorp

# Pre-create the org before user signups:
# 1. Bootstrap with admin user
# 2. Create "acmecorp" team org
# 3. Configure SSO/SAML pointing to this installation
# 4. Users auto-added to MEMBERS on first login
```

#### Multi-Tenant SaaS
```bash
# Don't set GRIST_SINGLE_ORG
# Users get personal orgs + can join teams
```

### Migration from Old Behavior

If you're upgrading from a version where personal orgs were created in single-team mode:

**Symptoms:**
- Personal org docs return 404
- Workspaces show docs that can't be opened

**Fix:**
```sql
-- Option 1: Delete orphaned personal orgs (CAUTION: data loss)
DELETE FROM orgs WHERE owner_id IS NOT NULL;

-- Option 2: Move docs from personal to team org
-- (Complex, requires moving workspaces and updating permissions)
```

**Prevention:** The new implementation prevents this scenario by not creating personal orgs in the first place.

## Testing

**File:** `test/gen-server/lib/homedb/UsersManager.ts` (lines 758-831)

Tests verify:
1. ✅ Personal org created when GRIST_SINGLE_ORG not set
2. ✅ Personal org created when GRIST_SINGLE_ORG=docs
3. ✅ Personal org NOT created when GRIST_SINGLE_ORG=teamname
4. ✅ User added to team org when GRIST_SINGLE_ORG=teamname
5. ✅ User creation succeeds even when team org doesn't exist

## API Behavior Guarantees

### Consistency Principle

**Before:** Resources could appear in listings but be inaccessible.

**After:** If a resource appears in an API response, it MUST be accessible via its detail endpoint.

### Examples

#### Multi-Org Mode (GRIST_SINGLE_ORG not set)
```bash
GET /api/orgs → [{id: 2, domain: "docs-5", name: "Personal"}, ...]
GET /api/orgs/2 → 200 OK
GET /api/docs/{docInPersonalOrg} → 200 OK ✓
```

#### Personal-Only Mode (GRIST_SINGLE_ORG=docs)
```bash
GET /api/orgs → [{id: 2, domain: "docs", name: "Personal"}, ...]
GET /api/orgs/2 → 200 OK
GET /api/docs/{docInPersonalOrg} → 200 OK ✓
```

#### Single Team Mode (GRIST_SINGLE_ORG=acmecorp)
```bash
GET /api/orgs → [{id: 1, domain: "acmecorp", name: "ACME Corp"}]
# No personal orgs in response
GET /api/docs/{docInTeamOrg} → 200 OK ✓
GET /api/docs/{docInPersonalOrg} → n/a (personal orgs don't exist)
```

## Future Considerations

### Backwards Compatibility Flag

**Not implemented** but could be added:
```bash
GRIST_LEGACY_PERSONAL_ORG_BEHAVIOR=true
```

Would restore old behavior of creating personal orgs regardless of GRIST_SINGLE_ORG, for deployments that need migration time.

### Automatic Migration Tool

A future enhancement could provide:
```bash
npm run migrate-personal-to-team -- --from-user={userId} --to-org={teamDomain}
```

To move existing personal org content to the team org.

### Explicit Personal Org Control

Instead of overloading GRIST_SINGLE_ORG, could add:
```bash
GRIST_ENABLE_PERSONAL_ORGS=true|false
GRIST_DEFAULT_ORG=teamname
```

For finer-grained control.

## Conclusion

The GRIST_SINGLE_ORG architecture now provides three coherent, defensible modes:

1. **Multi-org:** Full flexibility, personal + team orgs
2. **Personal-only:** Individual use, no teams
3. **Single-team:** Enterprise collaboration, no personal workspaces

The key architectural principle: **Resources that exist are always accessible.** No more zombie resources.

This design respects the principle of least surprise: when an admin configures `GRIST_SINGLE_ORG=teamname`, users truly belong to one team, without confusing personal org artifacts.
